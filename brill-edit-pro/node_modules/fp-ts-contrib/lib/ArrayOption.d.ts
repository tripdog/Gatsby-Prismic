/**
 * @since 0.1.0
 */
import { Alt1 } from 'fp-ts/lib/Alt'
import { Alternative1 } from 'fp-ts/lib/Alternative'
import { Applicative1 } from 'fp-ts/lib/Applicative'
import { Apply1 } from 'fp-ts/lib/Apply'
import { Functor1 } from 'fp-ts/lib/Functor'
import { Monad1 } from 'fp-ts/lib/Monad'
import { Option } from 'fp-ts/lib/Option'
/**
 * @category model
 * @since 0.1.0
 */
export interface ArrayOption<A> extends Array<Option<A>> {}
/**
 * @category constructors
 * @since 0.1.0
 */
export declare const fromArray: <A>(as: Array<A>) => ArrayOption<A>
/**
 * @category constructors
 * @since 0.1.0
 */
export declare const fromOption: <A>(ma: Option<A>) => ArrayOption<A>
/**
 * @category constructors
 * @since 0.1.10
 */
export declare const fromOptionK: <A extends Array<unknown>, B>(
  f: (...a: A) => Option<B>
) => (...a: A) => ArrayOption<B>
/**
 * @category constructors
 * @since 0.1.0
 */
export declare const none: ArrayOption<never>
/**
 * @category constructors
 * @since 0.1.0
 */
export declare const some: <A>(a: A) => ArrayOption<A>
/**
 * @category destructors
 * @since 0.1.0
 */
export declare const fold: <A, B>(
  onNone: () => Array<B>,
  onSome: (a: A) => Array<B>
) => (as: ArrayOption<A>) => Array<B>
/**
 * @category destructors
 * @since 0.1.0
 */
export declare const getOrElse: <A>(onNone: () => Array<A>) => (as: ArrayOption<A>) => Array<A>
/**
 * @category Functor
 * @since 0.1.18
 */
export declare const map: <A, B>(f: (a: A) => B) => (fa: ArrayOption<A>) => ArrayOption<B>
/**
 * @category Apply
 * @since 0.1.18
 */
export declare const ap: <A>(fa: ArrayOption<A>) => <B>(fab: ArrayOption<(a: A) => B>) => ArrayOption<B>
/**
 * @category Apply
 * @since 0.1.18
 */
export declare const apFirst: <B>(fb: ArrayOption<B>) => <A>(fa: ArrayOption<A>) => ArrayOption<A>
/**
 * @category Apply
 * @since 0.1.18
 */
export declare const apSecond: <B>(fb: ArrayOption<B>) => <A>(fa: ArrayOption<A>) => ArrayOption<B>
/**
 * @category Applicative
 * @since 0.1.18
 */
export declare const of: <A>(a: A) => ArrayOption<A>
/**
 * @category Monad
 * @since 0.1.10
 */
export declare const chainOptionK: <A, B>(f: (a: A) => Option<B>) => (ma: ArrayOption<A>) => ArrayOption<B>
/**
 * @category Monad
 * @since 0.1.18
 */
export declare const chain: <A, B>(f: (a: A) => ArrayOption<B>) => (fa: ArrayOption<A>) => ArrayOption<B>
/**
 * @category Monad
 * @since 0.1.18
 */
export declare const chainFirst: <A, B>(f: (a: A) => ArrayOption<B>) => (ma: ArrayOption<A>) => ArrayOption<A>
/**
 * @category Monad
 * @since 0.1.18
 */
export declare const flatten: <A>(mma: ArrayOption<ArrayOption<A>>) => ArrayOption<A>
/**
 * @category Alternative
 * @since 0.1.18
 */
export declare const alt: <A>(that: () => ArrayOption<A>) => (fa: ArrayOption<A>) => ArrayOption<A>
/**
 * @category Alternative
 * @since 0.1.18
 */
export declare const zero: Alternative1<URI>['zero']
/**
 * @category instances
 * @since 0.1.0
 */
export declare const URI = 'ArrayOption'
/**
 * @category instances
 * @since 0.1.0
 */
export declare type URI = typeof URI
declare module 'fp-ts/lib/HKT' {
  interface URItoKind<A> {
    ArrayOption: ArrayOption<A>
  }
}
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Functor: Functor1<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Applicative: Applicative1<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Apply: Apply1<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Monad: Monad1<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Alt: Alt1<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Alternative: Alternative1<URI>
/**
 * @category instances
 * @since 0.1.0
 */
export declare const arrayOption: Monad1<URI> & Alt1<URI>
