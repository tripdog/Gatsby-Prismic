"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var A = __importStar(require("fp-ts/lib/Array"));
var function_1 = require("fp-ts/lib/function");
var NEA = __importStar(require("fp-ts/lib/NonEmptyArray"));
var O = __importStar(require("fp-ts/lib/Option"));
var pipeable_1 = require("fp-ts/lib/pipeable");
var RA = __importStar(require("fp-ts/lib/ReadonlyArray"));
// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * Creates a new zipper.
 *
 * @category constructors
 * @since 0.1.6
 */
exports.make = function (lefts, focus, rights) { return ({
    lefts: lefts.slice(),
    focus: focus,
    rights: rights.slice()
}); };
/**
 * @category constructors
 * @since 0.1.23
 */
exports.fromReadonlyArray = function (as, focusIndex) {
    if (focusIndex === void 0) { focusIndex = 0; }
    if (RA.isEmpty(as) || RA.isOutOfBound(focusIndex, as)) {
        return O.none;
    }
    else {
        return O.some(exports.make(pipeable_1.pipe(as.slice(), A.takeLeft(focusIndex)), as[focusIndex], pipeable_1.pipe(as.slice(), A.dropLeft(focusIndex + 1))));
    }
};
/**
 * @category constructors
 * @since 0.1.6
 */
exports.fromArray = exports.fromReadonlyArray;
/**
 * @category constructors
 * @since 0.1.23
 */
exports.fromReadonlyNonEmptyArray = function (nea) {
    return exports.make([], nea[0], nea.slice(1));
};
/**
 * @category constructors
 * @since 0.1.6
 */
exports.fromNonEmptyArray = exports.fromReadonlyNonEmptyArray;
// -------------------------------------------------------------------------------------
// destructors
// -------------------------------------------------------------------------------------
/**
 * @category destructors
 * @since 0.1.18
 */
exports.isOutOfBound = function (index, fa) {
    return index < 0 || index >= exports.length(fa);
};
/**
 * @category destructors
 * @since 0.1.6
 */
exports.length = function (fa) { return fa.lefts.length + 1 + fa.rights.length; };
/**
 * @category destructors
 * @since 0.1.23
 */
exports.toNonEmptyArray = function (fa) {
    return pipeable_1.pipe(NEA.of(fa.focus), function (as) { return NEA.concat(fa.lefts, as); }, function (as) { return NEA.concat(as, fa.rights); });
};
/**
 * @category destructors
 * @since 0.1.23
 */
exports.toReadonlyNonEmptyArray = exports.toNonEmptyArray;
/**
 * @category destructors
 * @since 0.1.6
 * @deprecated Use the new {@link toNonEmptyArray} destructor instead.
 */
exports.toArray = exports.toNonEmptyArray;
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * Updates the focus of the zipper.
 *
 * @category combinators
 * @since 0.1.6
 */
exports.update = function (a) { return function (fa) { return exports.make(fa.lefts, a, fa.rights); }; };
/**
 * Applies `f` to the focus and update with the result.
 *
 * @category combinators
 * @since 0.1.6
 */
exports.modify = function (f) { return function (fa) { return pipeable_1.pipe(fa, exports.update(f(fa.focus))); }; };
/**
 * Moves focus in the zipper, or `None` if there is no such element.
 *
 * @category combinators
 * @since 0.1.6
 */
exports.move = function (f, fa) {
    var newIndex = f(fa.lefts.length);
    if (exports.isOutOfBound(newIndex, fa)) {
        return O.none;
    }
    else {
        return exports.fromArray(exports.toNonEmptyArray(fa), newIndex);
    }
};
/**
 * Find the first index for which a predicate holds.
 *
 * @category utils
 * @since 0.1.24
 */
exports.findIndex = function (predicate) { return function (fa) {
    return pipeable_1.pipe(fa.lefts, RA.findIndex(predicate), O.alt(function () { return (predicate(fa.focus) ? O.some(fa.lefts.length) : O.none); }), O.alt(function () {
        return pipeable_1.pipe(fa.rights, RA.findIndex(predicate), O.map(function (i) { return fa.lefts.length + 1 + i; }));
    }));
}; };
/**
 * Use a function to find and focus the first matching element in the array. If
 * no element matches, `None` is returned. If an element matches,
 * `Some<Zipper<A>>` is returned.
 *
 * @category combinators
 * @since 0.1.26
 */
exports.moveByFindFirst = function (predicate) { return function (fa) {
    return pipeable_1.pipe(fa, exports.findIndex(predicate), O.chain(function (i) { return (i === fa.lefts.length ? O.some(fa) : exports.move(function () { return i; }, fa)); }));
}; };
/**
 * Moves focus of the zipper up.
 *
 * @category combinators
 * @since 0.1.6
 */
exports.up = function (fa) { return exports.move(function_1.decrement, fa); };
/**
 * Moves focus of the zipper down.
 *
 * @category combinators
 * @since 0.1.6
 */
exports.down = function (fa) { return exports.move(function_1.increment, fa); };
/**
 * Moves focus to the start of the zipper.
 *
 * @category combinators
 * @since 0.1.6
 */
exports.start = function (fa) {
    if (A.isEmpty(fa.lefts)) {
        return fa;
    }
    else {
        return exports.make([], fa.lefts[0], A.snoc(pipeable_1.pipe(fa.lefts, A.dropLeft(1)), fa.focus).concat(fa.rights));
    }
};
/**
 * Moves focus to the end of the zipper.
 *
 * @category combinators
 * @since 0.1.6
 */
exports.end = function (fa) {
    var len = fa.rights.length;
    if (len === 0) {
        return fa;
    }
    else {
        return exports.make(A.snoc(fa.lefts, fa.focus).concat(pipeable_1.pipe(fa.rights, A.takeLeft(len - 1))), fa.rights[len - 1], []);
    }
};
/**
 * Inserts an element to the left of the focus and focuses on the new element.
 *
 * @category combinators
 * @since 0.1.6
 */
exports.insertLeft = function (a) { return function (fa) {
    return exports.make(fa.lefts, a, A.cons(fa.focus, fa.rights));
}; };
/**
 * Inserts an element to the right of the focus and focuses on the new element.
 *
 * @category combinators
 * @since 0.1.6
 */
exports.insertRight = function (a) { return function (fa) {
    return exports.make(A.snoc(fa.lefts, fa.focus), a, fa.rights);
}; };
/**
 * Deletes the element at focus and moves the focus to the left. If there is no element on the left,
 * the focus is moved to the right.
 *
 * @category combinators
 * @since 0.1.6
 */
exports.deleteLeft = function (fa) {
    var len = fa.lefts.length;
    return exports.fromArray(fa.lefts.concat(fa.rights), len > 0 ? len - 1 : 0);
};
/**
 * Deletes the element at focus and moves the focus to the right. If there is no element on the right,
 * the focus is moved to the left.
 *
 * @category combinators
 * @since 0.1.6
 */
exports.deleteRight = function (fa) {
    var lenl = fa.lefts.length;
    var lenr = fa.rights.length;
    return exports.fromArray(fa.lefts.concat(fa.rights), lenr > 0 ? lenl : lenl - 1);
};
// -------------------------------------------------------------------------------------
// non-pipeables
// -------------------------------------------------------------------------------------
var map_ = function (fa, f) { return exports.make(fa.lefts.map(f), f(fa.focus), fa.rights.map(f)); };
var mapWithIndex_ = function (fa, f) {
    var l = fa.lefts.length;
    return exports.make(fa.lefts.map(function (a, i) { return f(i, a); }), f(l, fa.focus), fa.rights.map(function (a, i) { return f(l + 1 + i, a); }));
};
var ap_ = function (fab, fa) {
    return exports.make(A.array.ap(fab.lefts, fa.lefts), fab.focus(fa.focus), A.array.ap(fab.rights, fa.rights));
};
var extend_ = function (fa, f) {
    var lefts = fa.lefts.map(function (a, i) {
        return f(exports.make(pipeable_1.pipe(fa.lefts, A.takeLeft(i)), a, A.snoc(pipeable_1.pipe(fa.lefts, A.dropLeft(i + 1)), fa.focus).concat(fa.rights)));
    });
    var rights = fa.rights.map(function (a, i) {
        return f(exports.make(A.snoc(fa.lefts, fa.focus).concat(pipeable_1.pipe(fa.rights, A.takeLeft(i))), a, pipeable_1.pipe(fa.rights, A.dropLeft(i + 1))));
    });
    return exports.make(lefts, f(fa), rights);
};
var reduce_ = function (fa, b, f) { return fa.rights.reduce(f, f(fa.lefts.reduce(f, b), fa.focus)); };
var reduceRight_ = function (fa, b, f) {
    var rights = fa.rights.reduceRight(function (acc, a) { return f(a, acc); }, b);
    var focus = f(fa.focus, rights);
    return fa.lefts.reduceRight(function (acc, a) { return f(a, acc); }, focus);
};
var foldMap_ = function (M) { return function (fa, f) {
    var lefts = fa.lefts.reduce(function (acc, a) { return M.concat(acc, f(a)); }, M.empty);
    var rights = fa.rights.reduce(function (acc, a) { return M.concat(acc, f(a)); }, M.empty);
    return M.concat(M.concat(lefts, f(fa.focus)), rights);
}; };
// TODO: add pipeable traverse fp-ts version >= 2.6.3
var traverse_ = function (F) {
    var traverseF = A.array.traverse(F);
    return function (ta, f) {
        return F.ap(F.ap(F.map(traverseF(ta.lefts, f), function (lefts) { return function (focus) { return function (rights) { return exports.make(lefts, focus, rights); }; }; }), f(ta.focus)), traverseF(ta.rights, f));
    };
};
// -------------------------------------------------------------------------------------
// pipeables
// -------------------------------------------------------------------------------------
/**
 * @category Functor
 * @since 0.1.18
 */
exports.map = function (f) { return function (fa) { return map_(fa, f); }; };
/**
 * @category FunctorWithIndex
 * @since 0.1.18
 */
exports.mapWithIndex = function (f) { return function (fa) {
    return mapWithIndex_(fa, f);
}; };
/**
 * @category Apply
 * @since 0.1.18
 */
exports.ap = function (fa) { return function (fab) { return ap_(fab, fa); }; };
/**
 * @category Apply
 * @since 0.1.18
 */
exports.apFirst = function (fb) { return function (fa) {
    return pipeable_1.pipe(fa, exports.map(function (a) { return function (_) { return a; }; }), exports.ap(fb));
}; };
/**
 * @category Apply
 * @since 0.1.18
 */
exports.apSecond = function (fb) { return function (fa) {
    return pipeable_1.pipe(fa, exports.map(function () { return function (b) { return b; }; }), exports.ap(fb));
}; };
/**
 * @category Applicative
 * @since 0.1.6
 */
exports.of = function (focus) { return exports.make([], focus, []); };
/**
 * @category Extend
 * @since 0.1.18
 */
exports.extend = function (f) { return function (wa) { return extend_(wa, f); }; };
/**
 * @category Extend
 * @since 0.1.18
 */
exports.duplicate = exports.extend(function_1.identity);
/**
 * @category Foldable
 * @since 0.1.18
 */
exports.foldMap = function (M) { return function (f) { return function (fa) {
    return foldMap_(M)(fa, f);
}; }; };
/**
 * @category Foldable
 * @since 0.1.18
 */
exports.reduce = function (b, f) { return function (fa) { return reduce_(fa, b, f); }; };
/**
 * @category Foldable
 * @since 0.1.18
 */
exports.reduceRight = function (b, f) { return function (fa) {
    return reduceRight_(fa, b, f);
}; };
/**
 * @category Traversable
 * @since 0.1.18
 */
exports.sequence = function (F) {
    var sequenceF = A.array.sequence(F);
    return function (ta) {
        return F.ap(F.ap(F.map(sequenceF(ta.lefts), function (lefts) { return function (focus) { return function (rights) { return exports.make(lefts, focus, rights); }; }; }), ta.focus), sequenceF(ta.rights));
    };
};
/**
 * @category Comonad
 * @since 0.1.18
 */
exports.extract = function (fa) { return fa.focus; };
// -------------------------------------------------------------------------------------
// instances
// -------------------------------------------------------------------------------------
/**
 * @category instances
 * @since 0.1.6
 */
exports.URI = 'Zipper';
/**
 * @category instances
 * @since 0.1.6
 */
exports.getShow = function (S) {
    var SA = A.getShow(S);
    return {
        show: function (fa) { return "Zipper(" + SA.show(fa.lefts) + ", " + S.show(fa.focus) + ", " + SA.show(fa.rights) + ")"; }
    };
};
/**
 * @category instances
 * @since 0.1.6
 */
exports.getSemigroup = function (S) { return ({
    concat: function (x, y) { return exports.make(x.lefts.concat(y.lefts), S.concat(x.focus, y.focus), x.rights.concat(y.rights)); }
}); };
/**
 * @category instances
 * @since 0.1.6
 */
exports.getMonoid = function (M) { return (__assign(__assign({}, exports.getSemigroup(M)), { empty: exports.make([], M.empty, []) })); };
/**
 * @category instances
 * @since 0.1.18
 */
exports.Functor = {
    URI: exports.URI,
    map: map_
};
/**
 * @category instances
 * @since 0.1.18
 */
exports.FunctorWithIndex = {
    URI: exports.URI,
    map: map_,
    mapWithIndex: mapWithIndex_
};
/**
 * @category instances
 * @since 0.1.18
 */
exports.Applicative = {
    URI: exports.URI,
    map: map_,
    ap: ap_,
    of: exports.of
};
/**
 * @category instances
 * @since 0.1.18
 */
exports.Apply = {
    URI: exports.URI,
    map: map_,
    ap: ap_
};
/**
 * @category instances
 * @since 0.1.18
 */
exports.Foldable = {
    URI: exports.URI,
    foldMap: foldMap_,
    reduce: reduce_,
    reduceRight: reduceRight_
};
/**
 * @category instances
 * @since 0.1.18
 */
exports.Traversable = {
    URI: exports.URI,
    map: map_,
    foldMap: foldMap_,
    reduce: reduce_,
    reduceRight: reduceRight_,
    traverse: traverse_,
    sequence: exports.sequence
};
/**
 * @category instances
 * @since 0.1.18
 */
exports.Comonad = {
    URI: exports.URI,
    map: map_,
    extend: extend_,
    extract: exports.extract
};
/**
 * @category instances
 * @since 0.1.6
 */
exports.zipper = {
    URI: exports.URI,
    map: map_,
    of: exports.of,
    ap: ap_,
    extend: extend_,
    extract: exports.extract,
    reduce: reduce_,
    reduceRight: reduceRight_,
    foldMap: foldMap_,
    traverse: traverse_,
    sequence: exports.sequence,
    mapWithIndex: mapWithIndex_
};
