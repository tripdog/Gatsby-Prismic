/**
 * @since 0.1.14
 */
import { Alt1 } from 'fp-ts/lib/Alt'
import { Applicative1 } from 'fp-ts/lib/Applicative'
import { Apply1 } from 'fp-ts/lib/Apply'
import { Alternative1 } from 'fp-ts/lib/Alternative'
import { Separated, Compactable1 } from 'fp-ts/lib/Compactable'
import { Either } from 'fp-ts/lib/Either'
import { Functor1 } from 'fp-ts/lib/Functor'
import * as O from 'fp-ts/lib/Option'
import { Filterable1 } from 'fp-ts/lib/Filterable'
import { Predicate, Refinement } from 'fp-ts/lib/function'
import { IO } from 'fp-ts/lib/IO'
import { IOEither } from 'fp-ts/lib/IOEither'
import { Monad1 } from 'fp-ts/lib/Monad'
import { MonadIO1 } from 'fp-ts/lib/MonadIO'
import { Monoid } from 'fp-ts/lib/Monoid'
import { Semigroup } from 'fp-ts/lib/Semigroup'
import Option = O.Option
/**
 * @category model
 * @since 0.1.14
 */
export interface IOOption<A> extends IO<Option<A>> {}
/**
 * @category constructors
 * @since 0.1.14
 */
export declare const none: IOOption<never>
/**
 * @category constructors
 * @since 0.1.14
 */
export declare const some: <A = never>(a: A) => IOOption<A>
/**
 * @category constructors
 * @since 0.1.14
 */
export declare const fromIO: <A = never>(ma: IO<A>) => IOOption<A>
/**
 * @category constructors
 * @since 0.1.14
 */
export declare const fromOption: <A = never>(ma: Option<A>) => IOOption<A>
/**
 * @category constructors
 * @since 0.1.14
 */
export declare const fromOptionK: <A extends Array<unknown>, B>(f: (...a: A) => Option<B>) => (...a: A) => IOOption<B>
/**
 * @category constructors
 * @since 0.1.14
 */
export declare const fromNullable: <A>(a: A) => IOOption<NonNullable<A>>
/**
 * @category constructors
 * @since 0.1.14
 */
export declare const fromIOEither: <A>(ma: IOEither<any, A>) => IOOption<A>
/**
 * @category destructors
 * @since 0.1.14
 */
export declare const fold: <A, B>(onNone: () => IO<B>, onSome: (a: A) => IO<B>) => (ma: IOOption<A>) => IO<B>
/**
 * @category destructors
 * @since 0.1.14
 */
export declare const getOrElse: <A>(onNone: () => IO<A>) => (ma: IOOption<A>) => IO<A>
/**
 * @category destructors
 * @since 0.1.14
 */
export declare const toUndefined: <A>(ma: IOOption<A>) => IO<A | undefined>
/**
 * @category destructors
 * @since 0.1.14
 */
export declare const toNullable: <A>(ma: IOOption<A>) => IO<A | null>
/**
 * @category combinators
 * @since 0.1.14
 */
export declare const mapNullable: <A, B>(f: (a: A) => B | null | undefined) => (ma: IOOption<A>) => IOOption<B>
/**
 * @category Functor
 * @since 0.1.18
 */
export declare const map: <A, B>(f: (a: A) => B) => (fa: IOOption<A>) => IOOption<B>
/**
 * @category Apply
 * @since 0.1.18
 */
export declare const ap: <A>(fa: IOOption<A>) => <B>(fab: IOOption<(a: A) => B>) => IOOption<B>
/**
 * @category Apply
 * @since 0.1.18
 */
export declare const apFirst: <B>(fb: IOOption<B>) => <A>(fa: IOOption<A>) => IOOption<A>
/**
 * @category Apply
 * @since 0.1.18
 */
export declare const apSecond: <B>(fb: IOOption<B>) => <A>(fa: IOOption<A>) => IOOption<B>
/**
 * @category Applicative
 * @since 0.1.18
 */
export declare const of: <A>(a: A) => IOOption<A>
/**
 * @category Monad
 * @since 0.1.18
 */
export declare const chain: <A, B>(f: (a: A) => IOOption<B>) => (ma: IOOption<A>) => IOOption<B>
/**
 * @category Monad
 * @since 0.1.18
 */
export declare const chainFirst: <A, B>(f: (a: A) => IOOption<B>) => (ma: IOOption<A>) => IOOption<A>
/**
 * @category Monad
 * @since 0.1.14
 */
export declare const chainOptionK: <A, B>(f: (a: A) => Option<B>) => (ma: IOOption<A>) => IOOption<B>
/**
 * @category Monad
 * @since 0.1.18
 */
export declare const flatten: <A>(mma: IOOption<IOOption<A>>) => IOOption<A>
/**
 * @category Alt
 * @since 0.1.18
 */
export declare const alt: <A>(that: () => IOOption<A>) => (fa: IOOption<A>) => IOOption<A>
/**
 * @category Alternative
 * @since 0.1.18
 */
export declare const zero: Alternative1<URI>['zero']
/**
 * @category Compactable
 * @since 0.1.18
 */
export declare const compact: <A>(fa: IOOption<O.Option<A>>) => IOOption<A>
/**
 * @category Compactable
 * @since 0.1.18
 */
export declare const separate: <A, B>(fa: IOOption<Either<A, B>>) => Separated<IOOption<A>, IOOption<B>>
/**
 * @category Filterable
 * @since 0.1.18
 */
export declare const filter: {
  <A, B extends A>(refinement: Refinement<A, B>): (fa: IOOption<A>) => IOOption<B>
  <A>(predicate: Predicate<A>): (fa: IOOption<A>) => IOOption<A>
}
/**
 * @category Filterable
 * @since 0.1.18
 */
export declare const filterMap: <A, B>(f: (a: A) => O.Option<B>) => (fa: IOOption<A>) => IOOption<B>
/**
 * @category Filterable
 * @since 0.1.18
 */
export declare const partition: {
  <A, B extends A>(refinement: Refinement<A, B>): (fa: IOOption<A>) => Separated<IOOption<A>, IOOption<B>>
  <A>(predicate: Predicate<A>): (fa: IOOption<A>) => Separated<IOOption<A>, IOOption<A>>
}
/**
 * @category Filterable
 * @since 0.1.18
 */
export declare const partitionMap: <A, B, C>(
  f: (a: A) => Either<B, C>
) => (fa: IOOption<A>) => Separated<IOOption<B>, IOOption<C>>
/**
 * @category instances
 * @since 0.1.14
 */
export declare const URI = 'IOOption'
/**
 * @category instances
 * @since 0.1.14
 */
export declare type URI = typeof URI
declare module 'fp-ts/lib/HKT' {
  interface URItoKind<A> {
    IOOption: IOOption<A>
  }
}
/**
 * @category instances
 * @since 0.1.14
 */
export declare const getApplySemigroup: <A>(S: Semigroup<A>) => Semigroup<IOOption<A>>
/**
 * @category instances
 * @since 0.1.14
 */
export declare const getApplyMonoid: <A>(M: Monoid<A>) => Monoid<IOOption<A>>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Functor: Functor1<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Applicative: Applicative1<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Apply: Apply1<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Monad: Monad1<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Alt: Alt1<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Alternative: Alternative1<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Compactable: Compactable1<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Filterable: Filterable1<URI>
/**
 * @since 0.1.14
 */
export declare const ioOption: Monad1<URI> & Alt1<URI> & MonadIO1<URI> & Filterable1<URI>
