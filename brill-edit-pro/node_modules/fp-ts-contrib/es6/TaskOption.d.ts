/**
 * @since 0.1.0
 */
import { Alternative1 } from 'fp-ts/es6/Alternative'
import { Applicative1 } from 'fp-ts/es6/Applicative'
import { Apply1 } from 'fp-ts/es6/Apply'
import { Separated, Compactable1 } from 'fp-ts/es6/Compactable'
import { Either } from 'fp-ts/es6/Either'
import { Filterable1 } from 'fp-ts/es6/Filterable'
import { Lazy, Predicate, Refinement } from 'fp-ts/es6/function'
import { Functor1 } from 'fp-ts/es6/Functor'
import { Monad1 } from 'fp-ts/es6/Monad'
import * as O from 'fp-ts/es6/Option'
import { Task } from 'fp-ts/es6/Task'
import { TaskEither } from 'fp-ts/es6/TaskEither'
/**
 * @category model
 * @since 0.1.0
 */
export interface TaskOption<A> extends Task<O.Option<A>> {}
/**
 * @category constructors
 * @since 0.1.0
 */
export declare const none: TaskOption<never>
/**
 * @category constructors
 * @since 0.1.0
 */
export declare const some: <A>(a: A) => TaskOption<A>
/**
 * @category constructors
 * @since 0.1.0
 */
export declare const fromOption: <A>(ma: O.Option<A>) => TaskOption<A>
/**
 * @category constructors
 * @since 0.1.10
 */
export declare const fromOptionK: <A extends Array<unknown>, B>(
  f: (...a: A) => O.Option<B>
) => (...a: A) => TaskOption<B>
/**
 * @category constructors
 * @since 0.1.0
 */
export declare const fromTask: <A>(as: Task<A>) => TaskOption<A>
/**
 * @category constructors
 * @since 0.1.4
 */
export declare const fromNullable: <A>(a: A) => TaskOption<NonNullable<A>>
/**
 * @category constructors
 * @since 0.1.4
 */
export declare const fromTaskEither: <A>(ma: TaskEither<any, A>) => TaskOption<A>
/**
 * @category constructors
 * @since 0.1.5
 */
export declare const tryCatch: <A>(f: Lazy<Promise<A>>) => TaskOption<A>
/**
 * @category destructors
 * @since 0.1.0
 */
export declare const fold: <A, B>(onNone: () => Task<B>, onSome: (a: A) => Task<B>) => (as: TaskOption<A>) => Task<B>
/**
 * @category destructors
 * @since 0.1.0
 */
export declare const getOrElse: <A>(onNone: () => Task<A>) => (as: TaskOption<A>) => Task<A>
/**
 * @category destructors
 * @since 0.1.4
 */
export declare const toUndefined: <A>(ma: TaskOption<A>) => Task<A | undefined>
/**
 * @category destructors
 * @since 0.1.4
 */
export declare const toNullable: <A>(ma: TaskOption<A>) => Task<A | null>
/**
 * @category combinators
 * @since 0.1.5
 */
export declare const mapNullable: <A, B>(f: (a: A) => B | null | undefined) => (ma: TaskOption<A>) => TaskOption<B>
/**
 * @category Functor
 * @since 0.1.18
 */
export declare const map: <A, B>(f: (a: A) => B) => (fa: TaskOption<A>) => TaskOption<B>
/**
 * @category Apply
 * @since 0.1.18
 */
export declare const ap: <A>(fa: TaskOption<A>) => <B>(fab: TaskOption<(a: A) => B>) => TaskOption<B>
/**
 * @category Apply
 * @since 0.1.18
 */
export declare const apFirst: <B>(fb: TaskOption<B>) => <A>(fa: TaskOption<A>) => TaskOption<A>
/**
 * @category Apply
 * @since 0.1.18
 */
export declare const apSecond: <B>(fb: TaskOption<B>) => <A>(fa: TaskOption<A>) => TaskOption<B>
/**
 * @category Applicative
 * @since 0.1.18
 */
export declare const of: <A>(a: A) => TaskOption<A>
/**
 * @category Monad
 * @since 0.1.18
 */
export declare const chain: <A, B>(f: (a: A) => TaskOption<B>) => (ma: TaskOption<A>) => TaskOption<B>
/**
 * @category Monad
 * @since 0.1.18
 */
export declare const chainFirst: <A, B>(f: (a: A) => TaskOption<B>) => (ma: TaskOption<A>) => TaskOption<A>
/**
 * @category Monad
 * @since 0.1.4
 */
export declare const chainTask: <A, B>(f: (a: A) => Task<B>) => (ma: TaskOption<A>) => TaskOption<B>
/**
 * @category Monad
 * @since 0.1.4
 */
export declare const chainOption: <A, B>(f: (a: A) => O.Option<B>) => (ma: TaskOption<A>) => TaskOption<B>
/**
 * @category Monad
 * @since 0.1.10
 */
export declare const chainOptionK: <A, B>(f: (a: A) => O.Option<B>) => (ma: TaskOption<A>) => TaskOption<B>
/**
 * @category Monad
 * @since 0.1.18
 */
export declare const flatten: <A>(mma: TaskOption<TaskOption<A>>) => TaskOption<A>
/**
 * @category Alternative
 * @since 0.1.18
 */
export declare const alt: <A>(that: () => TaskOption<A>) => (fa: TaskOption<A>) => TaskOption<A>
/**
 * @category Alternative
 * @since 0.1.18
 */
export declare const zero: <A>() => TaskOption<A>
/**
 * @category Compactable
 * @since 0.1.18
 */
export declare const compact: <A>(fa: TaskOption<O.Option<A>>) => TaskOption<A>
/**
 * @category Compactable
 * @since 0.1.18
 */
export declare const separate: <A, B>(ma: TaskOption<Either<A, B>>) => Separated<TaskOption<A>, TaskOption<B>>
/**
 * @category Filterable
 * @since 0.1.18
 */
export declare const filter: {
  <A, B extends A>(refinement: Refinement<A, B>): (fa: TaskOption<A>) => TaskOption<B>
  <A>(predicate: Predicate<A>): (fa: TaskOption<A>) => TaskOption<A>
}
/**
 * @category Filterable
 * @since 0.1.18
 */
export declare const filterMap: <A, B>(f: (a: A) => O.Option<B>) => (fa: TaskOption<A>) => TaskOption<B>
/**
 * @category Filterable
 * @since 0.1.18
 */
export declare const partition: {
  <A, B extends A>(refinement: Refinement<A, B>): (fa: TaskOption<A>) => Separated<TaskOption<A>, TaskOption<B>>
  <A>(predicate: Predicate<A>): (fa: TaskOption<A>) => Separated<TaskOption<A>, TaskOption<A>>
}
/**
 * @category Filterable
 * @since 0.1.18
 */
export declare const partitionMap: <A, B, C>(
  f: (a: A) => Either<B, C>
) => (fa: TaskOption<A>) => Separated<TaskOption<B>, TaskOption<C>>
/**
 * @category instances
 * @since 0.1.0
 */
declare const URI = 'TaskOption'
/**
 * @category instances
 * @since 0.1.0
 */
export declare type URI = typeof URI
declare module 'fp-ts/es6/HKT' {
  interface URItoKind<A> {
    TaskOption: TaskOption<A>
  }
}
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Functor: Functor1<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Applicative: Applicative1<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Apply: Apply1<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Monad: Monad1<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Alternative: Alternative1<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Compactable: Compactable1<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Filterable: Filterable1<URI>
/**
 * @category instances
 * @since 0.1.0
 */
export declare const taskOption: Monad1<URI> & Alternative1<URI> & Filterable1<URI>
export {}
