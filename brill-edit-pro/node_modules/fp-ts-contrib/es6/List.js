var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as A from 'fp-ts/es6/Array';
import { intercalate } from 'fp-ts/es6/Foldable';
import { flow } from 'fp-ts/es6/function';
import { monoidString } from 'fp-ts/es6/Monoid';
import * as O from 'fp-ts/es6/Option';
import { pipe } from 'fp-ts/es6/pipeable';
// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * @category constructors
 * @since 0.1.8
 */
export var nil = { type: 'Nil', length: 0 };
/**
 * Attaches an element to the front of a list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.deepStrictEqual(L.cons('a', L.nil), { type: 'Cons', head: 'a', tail: L.nil, length: 1 })
 *
 * @category constructors
 * @since 0.1.8
 */
export var cons = function (head, tail) { return ({
    type: 'Cons',
    head: head,
    tail: tail,
    length: 1 + tail.length
}); };
/**
 * Creates a list from an array
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.deepStrictEqual(L.fromArray([]), L.nil)
 * assert.deepStrictEqual(L.fromArray(['a', 'b']), L.cons('a', L.of('b')))
 *
 * @category constructors
 * @since 0.1.8
 */
export var fromArray = function (as) { return A.array.reduceRight(as, nil, cons); };
// -------------------------------------------------------------------------------------
// destructors
// -------------------------------------------------------------------------------------
/**
 * Gets the first element in a list, or `None` if the list is empty.
 *
 * @example
 * import * as O from 'fp-ts/Option'
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.deepStrictEqual(L.head(L.nil), O.none)
 * assert.deepStrictEqual(L.head(L.cons('x', L.of('a'))), O.some('x'))
 *
 * @category destructors
 * @since 0.1.8
 */
export var head = function (fa) { return (isCons(fa) ? O.some(fa.head) : O.none); };
/**
 * Gets all but the first element of a list, or `None` if the list is empty.
 *
 * @example
 * import * as O from 'fp-ts/Option'
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.deepStrictEqual(L.tail(L.nil), O.none)
 * assert.deepStrictEqual(L.tail(L.of('a')), O.some(L.nil))
 * assert.deepStrictEqual(L.tail(L.cons('x', L.of('a'))), O.some(L.of('a')))
 *
 * @category destructors
 * @since 0.1.8
 */
export var tail = function (fa) { return (isCons(fa) ? O.some(fa.tail) : O.none); };
/**
 * Breaks a list into its first element and the remaining elements.
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * const len: <A>(as: L.List<A>) => number = L.foldLeft(
 *   () => 0,
 *   (_, tail) => 1 + len(tail)
 * )
 * assert.deepStrictEqual(len(L.cons('a', L.of('b'))), 2)
 *
 * @category destructors
 * @since 0.1.8
 */
export var foldLeft = function (onNil, onCons) { return function (fa) { return (isNil(fa) ? onNil() : onCons(fa.head, fa.tail)); }; };
/**
 * Gets an array from a list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.deepStrictEqual(L.toArray(L.cons('a', L.of('b'))), ['a', 'b'])
 *
 * @category destructors
 * @since 0.1.8
 */
export var toArray = function (fa) {
    var length = fa.length;
    var out = new Array(length);
    var l = fa;
    for (var i = 0; i < length; i++) {
        out[i] = l.head;
        l = l.tail;
    }
    return out;
};
/**
 * Gets an array from a list in a reversed order.
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.deepStrictEqual(L.toReversedArray(L.cons('a', L.of('b'))), ['b', 'a'])
 *
 * @category destructors
 * @since 0.1.8
 */
export var toReversedArray = function (fa) {
    var length = fa.length;
    var out = new Array(length);
    var l = fa;
    for (var i = 0; i < length; i++) {
        out[length - i - 1] = l.head;
        l = l.tail;
    }
    return out;
};
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * Reverse a list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.deepStrictEqual(L.reverse(L.cons(1, L.cons(2, L.of(3)))), L.cons(3, L.cons(2, L.of(1))))
 *
 * @category combinators
 * @since 0.1.8
 */
export var reverse = function (fa) {
    var out = nil;
    var l = fa;
    while (isCons(l)) {
        out = cons(l.head, out);
        l = l.tail;
    }
    return out;
};
/**
 * Drops the specified number of elements from the front of a list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.deepStrictEqual(L.dropLeft(1)(L.nil), L.nil)
 * assert.deepStrictEqual(L.dropLeft(1)(L.cons(1, L.of(2))), L.of(2))
 * assert.deepStrictEqual(L.dropLeft(3)(L.cons(1, L.of(2))), L.nil)
 *
 * @category combinators
 * @since 0.1.8
 */
export var dropLeft = function (n) { return function (fa) {
    if (isNil(fa))
        return nil;
    var i = 0;
    var l = fa;
    while (isCons(l) && i < n) {
        i++;
        l = l.tail;
    }
    return l;
}; };
export function dropLeftWhile(predicate) {
    return function (fa) {
        if (isNil(fa))
            return nil;
        var l = fa;
        while (isCons(l) && predicate(l.head)) {
            l = l.tail;
        }
        return l;
    };
}
// -------------------------------------------------------------------------------------
// non-pipeables
// -------------------------------------------------------------------------------------
var map_ = function (fa, f) { return pipe(fa, map(f)); };
var ap_ = function (fab, fa) { return pipe(fab, ap(fa)); };
var chain_ = function (ma, f) { return pipe(ma, chain(f)); };
var reduce_ = function (fa, b, f) { return pipe(fa, reduce(b, f)); };
var reduceRight_ = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };
var foldMap_ = function (M) { return function (fa, f) { return pipe(fa, foldMap(M)(f)); }; };
var traverse_ = function (F) {
    return function (ta, f) {
        return list.reduceRight(ta, F.of(nil), function (a, fbs) {
            return F.ap(F.map(fbs, function (bs) { return function (b) { return cons(b, bs); }; }), f(a));
        });
    };
};
var sequence_ = function (F) { return function (ta) {
    return list.reduceRight(ta, F.of(nil), function (a, fas) {
        return F.ap(F.map(fas, function (as) { return function (a) { return cons(a, as); }; }), a);
    });
}; };
// -------------------------------------------------------------------------------------
// pipeables
// -------------------------------------------------------------------------------------
/**
 * @category Functor
 * @since 0.1.18
 */
export var map = function (f) { return function (fa) {
    return pipe(toArray(fa), A.reduceRight(nil, function (a, b) { return cons(f(a), b); }));
}; };
/**
 * @category Functor
 * @since 0.1.20
 */
export var ap = function (fa) { return chain(function (f) { return pipe(fa, map(f)); }); };
/**
 * @category Apply
 * @since 0.1.20
 */
export var apFirst = function (fb) {
    return flow(map(function (a) { return function () { return a; }; }), ap(fb));
};
/**
 * @category Apply
 * @since 0.1.20
 */
export var apSecond = function (fb) {
    return flow(map(function () { return function (b) { return b; }; }), ap(fb));
};
/**
 * @category Monad
 * @since 0.1.20
 */
export var chain = function (f) { return function (ma) {
    return pipe(ma, foldLeft(function () { return nil; }, function (x, xs) {
        var S = getSemigroup();
        var out = f(x);
        var l = xs;
        while (isCons(l)) {
            out = S.concat(out, f(l.head));
            l = l.tail;
        }
        return out;
    }));
}; };
/**
 * @category Monad
 * @since 0.1.20
 */
export var chainFirst = function (f) {
    return chain(function (a) {
        return pipe(f(a), map(function () { return a; }));
    });
};
/**
 * @category Foldable
 * @since 0.1.18
 */
export var reduce = function (b, f) { return function (fa) {
    var out = b;
    var l = fa;
    while (isCons(l)) {
        out = f(out, l.head);
        l = l.tail;
    }
    return out;
}; };
/**
 * @category Foldable
 * @since 0.1.18
 */
export var reduceRight = function (b, f) { return function (fa) {
    return pipe(toArray(fa), A.reduceRight(b, f));
}; };
/**
 * @category Foldable
 * @since 0.1.18
 */
export var foldMap = function (M) { return function (f) { return function (fa) {
    var out = M.empty;
    var l = fa;
    while (isCons(l)) {
        out = M.concat(out, f(l.head));
        l = l.tail;
    }
    return out;
}; }; };
// TODO: add pipeable traverse when fp-ts version >= 2.6.3
// /**
//  * @category Traversable
//  * @since 0.1.18
//  */
// export const traverse: PipeableTraverse1<URI> = <F>(
//   F: Applicative<F>
// ): (<A, B>(f: (a: A) => HKT<F, B>) => (ta: List<A>) => HKT<F, List<B>>) => {
//   const traverseF = traverse_(F)
//   return f => ta => traverseF(ta, f)
// }
/**
 * @category Traversable
 * @since 0.1.18
 */
export var sequence = function (F) { return sequence_(F); };
/**
 * Creates a list with a single element.
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.deepStrictEqual(L.of('a'), L.cons('a', L.nil))
 *
 * @category Applicative
 * @since 0.1.8
 */
export var of = function (head) { return cons(head, nil); };
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * Finds the first index for which a predicate holds.
 *
 * @example
 * import * as O from 'fp-ts/Option'
 * import * as L from 'fp-ts-contrib/List'
 *
 * const f = (a: number): boolean => a % 2 === 0
 * const findIndexEven = L.findIndex(f)
 * assert.deepStrictEqual(findIndexEven(L.nil), O.none)
 * assert.deepStrictEqual(findIndexEven(L.cons(1, L.of(2))), O.some(1))
 * assert.deepStrictEqual(findIndexEven(L.of(1)), O.none)
 *
 * @since 0.1.8
 */
export var findIndex = function (predicate) { return function (fa) {
    var l = fa;
    var i = 0;
    while (isCons(l)) {
        if (predicate(l.head))
            return O.some(i);
        l = l.tail;
        i++;
    }
    return O.none;
}; };
// -------------------------------------------------------------------------------------
// instances
// -------------------------------------------------------------------------------------
/**
 * @category instances
 * @since 0.1.8
 */
export var URI = 'List';
/**
 * Derives an `Eq` over the `List` of a given element type from the `Eq` of that type.
 * The derived `Eq` defines two lists as equal if all elements of both lists
 * are compared equal pairwise with the given `E`. In case of lists of different
 * lengths, the result is non equality.
 *
 * @example
 * import { eqString } from 'fp-ts/Eq'
 * import * as L from 'fp-ts-contrib/List'
 *
 * const E = L.getEq(eqString)
 * assert.strictEqual(E.equals(L.cons('a', L.of('b')), L.cons('a', L.of('b'))), true)
 * assert.strictEqual(E.equals(L.of('x'), L.nil), false)
 *
 * @category instances
 * @since 0.1.8
 */
export var getEq = function (E) { return ({
    equals: function (x, y) {
        if (x.length !== y.length)
            return false;
        var lx = x;
        var ly = y;
        while (isCons(lx) && isCons(ly)) {
            if (!E.equals(lx.head, ly.head))
                return false;
            lx = lx.tail;
            ly = ly.tail;
        }
        return true;
    }
}); };
/**
 * @category instances
 * @since 0.1.20
 */
export var getShow = function (S) { return ({
    show: function (as) {
        return pipe(as, map(S.show), foldLeft(function () { return 'Nil'; }, function (x, xs) { return "(" + intercalate(monoidString, Foldable)(' : ', cons(x, xs)) + " : Nil)"; }));
    }
}); };
/**
 * @category instances
 * @since 0.1.20
 */
export var getSemigroup = function () { return ({
    concat: function (xs, ys) { return pipe(xs, reduceRight(ys, cons)); }
}); };
/**
 * @category instances
 * @since 0.1.20
 */
export var getMonoid = function () { return (__assign(__assign({}, getSemigroup()), { empty: nil })); };
/**
 * @category instances
 * @since 0.1.18
 */
export var Functor = {
    URI: URI,
    map: map_
};
/**
 * @category instances
 * @since 0.1.20
 */
export var Apply = {
    URI: URI,
    map: map_,
    ap: ap_
};
/**
 * @category instances
 * @since 0.1.20
 */
export var Applicative = {
    URI: URI,
    map: map_,
    ap: ap_,
    of: of
};
/**
 * @category instances
 * @since 0.1.20
 */
export var Monad = {
    URI: URI,
    map: map_,
    ap: ap_,
    of: of,
    chain: chain_
};
/**
 * @category instances
 * @since 0.1.18
 */
export var Foldable = {
    URI: URI,
    foldMap: foldMap_,
    reduce: reduce_,
    reduceRight: reduceRight_
};
/**
 * @category instances
 * @since 0.1.18
 */
export var Traversable = {
    URI: URI,
    map: map_,
    foldMap: foldMap_,
    reduce: reduce_,
    reduceRight: reduceRight_,
    traverse: traverse_,
    sequence: sequence_
};
/**
 * @category instances
 * @since 0.1.8
 */
export var list = {
    URI: URI,
    map: map_,
    reduce: reduce_,
    foldMap: foldMap_,
    reduceRight: reduceRight_,
    traverse: traverse_,
    sequence: sequence_
};
// -------------------------------------------------------------------------------------
// do notation
// -------------------------------------------------------------------------------------
/**
 * @internal
 */
var bind_ = function (a, name, b) {
    var _a;
    return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
};
/**
 * @since 0.1.20
 */
export var bindTo = function (name) { return function (fa) {
    return pipe(fa, map(function (a) { return bind_({}, name, a); }));
}; };
/**
 * @since 0.1.20
 */
export var bind = function (name, f) { return function (fa) {
    return pipe(fa, chain(function (a) {
        return pipe(f(a), map(function (b) { return bind_(a, name, b); }));
    }));
}; };
// -------------------------------------------------------------------------------------
// pipeable sequence S
// -------------------------------------------------------------------------------------
/**
 * @since 0.1.20
 */
export var apS = function (name, fb) {
    return flow(map(function (a) { return function (b) { return bind_(a, name, b); }; }), ap(fb));
};
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * Tests whether a list is an empty list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.strictEqual(L.isNil(L.nil), true)
 * assert.strictEqual(L.isNil(L.of(6)), false)
 *
 * @since 0.1.8
 */
export var isNil = function (a) { return a.type === 'Nil'; };
/**
 * Tests whether a list is a non empty list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.strictEqual(L.isCons(L.nil), false)
 * assert.strictEqual(L.isCons(L.of(1)), true)
 *
 * @since 0.1.8
 */
export var isCons = function (a) { return a.type === 'Cons'; };
