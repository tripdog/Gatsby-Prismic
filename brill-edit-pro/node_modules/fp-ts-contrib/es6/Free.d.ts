/**
 * @since 0.1.3
 */
import { Applicative2 } from 'fp-ts/es6/Applicative'
import { Apply2 } from 'fp-ts/es6/Apply'
import { Functor2 } from 'fp-ts/es6/Functor'
import { HKT, Kind, Kind2, Kind3, URIS, URIS2, URIS3 } from 'fp-ts/es6/HKT'
import { Monad, Monad1, Monad2, Monad2C, Monad3 } from 'fp-ts/es6/Monad'
/**
 * @data
 * @constructor Pure
 * @constructor Impure
 * @category model
 * @since 0.1.3
 */
export declare type Free<F, A> = Pure<F, A> | Impure<F, A, any>
interface Pure<_F, A> {
  readonly _tag: 'Pure'
  readonly value: A
}
interface Impure<F, A, X> {
  readonly _tag: 'Impure'
  readonly fx: HKT<F, X>
  readonly f: (x: X) => Free<F, A>
}
/**
 * Lift an impure value described by the generating type constructor `F` into the free monad
 *
 * @category constructors
 * @since 0.1.3
 */
export declare const liftF: <F, A>(fa: HKT<F, A>) => Free<F, A>
/**
 * @category destructors
 * @since 0.1.3
 */
export interface FoldFree3<M extends URIS3> {
  <F extends URIS3, U, L, A>(nt: <X>(fa: Kind3<F, U, L, X>) => Kind3<M, U, L, X>, fa: Free<F, A>): Kind3<M, U, L, A>
  <F extends URIS2, U, L, A>(nt: <X>(fa: Kind2<F, L, X>) => Kind3<M, U, L, X>, fa: Free<F, A>): Kind3<M, U, L, A>
  <F extends URIS, U, L, A>(nt: <X>(fa: Kind<F, X>) => Kind3<M, U, L, X>, fa: Free<F, A>): Kind3<M, U, L, A>
}
/**
 * @category destructors
 * @since 0.1.3
 */
export interface FoldFree2<M extends URIS2> {
  <F extends URIS2, L, A>(nt: <X>(fa: Kind2<F, L, X>) => Kind2<M, L, X>, fa: Free<F, A>): Kind2<M, L, A>
  <F extends URIS, L, A>(nt: <X>(fa: Kind<F, X>) => Kind2<M, L, X>, fa: Free<F, A>): Kind2<M, L, A>
}
/**
 * @category destructors
 * @since 0.1.3
 */
export interface FoldFree2C<M extends URIS2, L> {
  <F extends URIS2, A>(nt: <X>(fa: Kind2<F, L, X>) => Kind2<M, L, X>, fa: Free<F, A>): Kind2<M, L, A>
  <F extends URIS, A>(nt: <X>(fa: Kind<F, X>) => Kind2<M, L, X>, fa: Free<F, A>): Kind2<M, L, A>
}
/**
 * Perform folding of a free monad using given natural transformation as an interpreter
 *
 * @category destructors
 * @since 0.1.3
 */
export declare function foldFree<M extends URIS3>(M: Monad3<M>): FoldFree3<M>
export declare function foldFree<M extends URIS2>(M: Monad2<M>): FoldFree2<M>
export declare function foldFree<M extends URIS2, L>(M: Monad2C<M, L>): FoldFree2C<M, L>
export declare function foldFree<M extends URIS>(
  M: Monad1<M>
): <F extends URIS, A>(nt: <X>(fa: Kind<F, X>) => Kind<M, X>, fa: Free<F, A>) => Kind<M, A>
export declare function foldFree<M>(
  M: Monad<M>
): <F, A>(nt: <X>(fa: HKT<F, X>) => HKT<M, X>, fa: Free<F, A>) => HKT<M, A>
/**
 * Use a natural transformation to change the generating type constructor of a free monad
 *
 * @category combinators
 * @since 0.1.3
 */
export declare function hoistFree<F extends URIS3 = never, G extends URIS3 = never>(
  nt: <U, L, A>(fa: Kind3<F, U, L, A>) => Kind3<G, U, L, A>
): <A>(fa: Free<F, A>) => Free<G, A>
export declare function hoistFree<F extends URIS2 = never, G extends URIS2 = never>(
  nt: <L, A>(fa: Kind2<F, L, A>) => Kind2<G, L, A>
): <A>(fa: Free<F, A>) => Free<G, A>
export declare function hoistFree<F extends URIS = never, G extends URIS = never>(
  nt: <A>(fa: Kind<F, A>) => Kind<G, A>
): <A>(fa: Free<F, A>) => Free<G, A>
export declare function hoistFree<F, G>(nt: <A>(fa: HKT<F, A>) => HKT<G, A>): <A>(fa: Free<F, A>) => Free<G, A>
/**
 * @category Functor
 * @since 0.1.18
 */
export declare const map: <A, B>(f: (a: A) => B) => <F>(fa: Free<F, A>) => Free<F, B>
/**
 * @category Apply
 * @since 0.1.18
 */
export declare const ap: <F, A, B>(fa: Free<F, A>) => (fab: Free<F, (a: A) => B>) => Free<F, B>
/**
 * @category Monad
 * @since 0.1.18
 */
export declare const chain: <F, A, B>(f: (a: A) => Free<F, B>) => (ma: Free<F, A>) => Free<F, B>
/**
 * @category Monad
 * @since 0.1.18
 */
export declare const flatten: <E, A>(mma: Free<E, Free<E, A>>) => Free<E, A>
/**
 * @category Applicative
 * @since 0.1.18
 */
export declare const of: <F, A>(a: A) => Free<F, A>
/**
 * @category instances
 * @since 0.1.3
 */
export declare const URI = 'Free'
/**
 * @category instances
 * @since 0.1.3
 */
export declare type URI = typeof URI
declare module 'fp-ts/es6/HKT' {
  interface URItoKind2<E, A> {
    Free: Free<E, A>
  }
}
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Functor: Functor2<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Applicative: Applicative2<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Apply: Apply2<URI>
/**
 * Monad instance for Free
 *
 * @category instances
 * @since 0.1.3
 */
export declare const free: Monad2<URI>
/**
 * Check if given Free instance is Pure
 *
 * @since 0.1.3
 */
export declare const isPure: <F, A>(fa: Free<F, A>) => fa is Pure<F, A>
/**
 * Check if given Free instance is Impure
 *
 * @since 0.1.3
 */
export declare const isImpure: <F, A>(fa: Free<F, A>) => fa is Impure<F, A, any>
export {}
