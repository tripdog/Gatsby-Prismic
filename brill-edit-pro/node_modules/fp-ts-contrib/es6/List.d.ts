/**
 * Adapted from https://github.com/purescript/purescript-lists
 *
 * @since 0.1.8
 */
import { Applicative1 } from 'fp-ts/es6/Applicative'
import { Apply1 } from 'fp-ts/es6/Apply'
import * as Eq from 'fp-ts/es6/Eq'
import { Foldable1 } from 'fp-ts/es6/Foldable'
import { Predicate, Refinement } from 'fp-ts/es6/function'
import { Functor1 } from 'fp-ts/es6/Functor'
import { Monad1 } from 'fp-ts/es6/Monad'
import { Monoid } from 'fp-ts/es6/Monoid'
import * as O from 'fp-ts/es6/Option'
import { Semigroup } from 'fp-ts/es6/Semigroup'
import { Show } from 'fp-ts/es6/Show'
import { Traversable1 } from 'fp-ts/es6/Traversable'
/**
 * @category model
 * @since 0.1.8
 */
export interface Nil {
  readonly type: 'Nil'
  readonly length: 0
}
/**
 * @category model
 * @since 0.1.8
 */
export interface Cons<A> {
  readonly type: 'Cons'
  readonly head: A
  readonly tail: List<A>
  readonly length: number
}
/**
 * @category model
 * @since 0.1.8
 */
export declare type List<A> = Nil | Cons<A>
/**
 * @category constructors
 * @since 0.1.8
 */
export declare const nil: List<never>
/**
 * Attaches an element to the front of a list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.deepStrictEqual(L.cons('a', L.nil), { type: 'Cons', head: 'a', tail: L.nil, length: 1 })
 *
 * @category constructors
 * @since 0.1.8
 */
export declare const cons: <A>(head: A, tail: List<A>) => List<A>
/**
 * Creates a list from an array
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.deepStrictEqual(L.fromArray([]), L.nil)
 * assert.deepStrictEqual(L.fromArray(['a', 'b']), L.cons('a', L.of('b')))
 *
 * @category constructors
 * @since 0.1.8
 */
export declare const fromArray: <A>(as: A[]) => List<A>
/**
 * Gets the first element in a list, or `None` if the list is empty.
 *
 * @example
 * import * as O from 'fp-ts/Option'
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.deepStrictEqual(L.head(L.nil), O.none)
 * assert.deepStrictEqual(L.head(L.cons('x', L.of('a'))), O.some('x'))
 *
 * @category destructors
 * @since 0.1.8
 */
export declare const head: <A>(fa: List<A>) => O.Option<A>
/**
 * Gets all but the first element of a list, or `None` if the list is empty.
 *
 * @example
 * import * as O from 'fp-ts/Option'
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.deepStrictEqual(L.tail(L.nil), O.none)
 * assert.deepStrictEqual(L.tail(L.of('a')), O.some(L.nil))
 * assert.deepStrictEqual(L.tail(L.cons('x', L.of('a'))), O.some(L.of('a')))
 *
 * @category destructors
 * @since 0.1.8
 */
export declare const tail: <A>(fa: List<A>) => O.Option<List<A>>
/**
 * Breaks a list into its first element and the remaining elements.
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * const len: <A>(as: L.List<A>) => number = L.foldLeft(
 *   () => 0,
 *   (_, tail) => 1 + len(tail)
 * )
 * assert.deepStrictEqual(len(L.cons('a', L.of('b'))), 2)
 *
 * @category destructors
 * @since 0.1.8
 */
export declare const foldLeft: <A, B>(onNil: () => B, onCons: (head: A, tail: List<A>) => B) => (fa: List<A>) => B
/**
 * Gets an array from a list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.deepStrictEqual(L.toArray(L.cons('a', L.of('b'))), ['a', 'b'])
 *
 * @category destructors
 * @since 0.1.8
 */
export declare const toArray: <A>(fa: List<A>) => A[]
/**
 * Gets an array from a list in a reversed order.
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.deepStrictEqual(L.toReversedArray(L.cons('a', L.of('b'))), ['b', 'a'])
 *
 * @category destructors
 * @since 0.1.8
 */
export declare const toReversedArray: <A>(fa: List<A>) => A[]
/**
 * Reverse a list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.deepStrictEqual(L.reverse(L.cons(1, L.cons(2, L.of(3)))), L.cons(3, L.cons(2, L.of(1))))
 *
 * @category combinators
 * @since 0.1.8
 */
export declare const reverse: <A>(fa: List<A>) => List<A>
/**
 * Drops the specified number of elements from the front of a list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.deepStrictEqual(L.dropLeft(1)(L.nil), L.nil)
 * assert.deepStrictEqual(L.dropLeft(1)(L.cons(1, L.of(2))), L.of(2))
 * assert.deepStrictEqual(L.dropLeft(3)(L.cons(1, L.of(2))), L.nil)
 *
 * @category combinators
 * @since 0.1.8
 */
export declare const dropLeft: (n: number) => <A>(fa: List<A>) => List<A>
/**
 * Drops those elements from the front of a list which match a predicate.
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * const isLTThree = (n: number) => n < 3
 * assert.deepStrictEqual(L.dropLeftWhile(isLTThree)(L.nil), L.nil)
 * assert.deepStrictEqual(L.dropLeftWhile(isLTThree)(L.cons(1, L.cons(2, L.of(3)))), L.of(3))
 * assert.deepStrictEqual(L.dropLeftWhile(isLTThree)(L.cons(1, L.of(2))), L.nil)
 *
 * @since 0.1.8
 */
export declare function dropLeftWhile<A, B extends A>(refinement: Refinement<A, B>): (fa: List<A>) => List<B>
export declare function dropLeftWhile<A>(predicate: Predicate<A>): (fa: List<A>) => List<A>
/**
 * @category Functor
 * @since 0.1.18
 */
export declare const map: <A, B>(f: (a: A) => B) => (fa: List<A>) => List<B>
/**
 * @category Functor
 * @since 0.1.20
 */
export declare const ap: <A>(fa: List<A>) => <B>(fab: List<(a: A) => B>) => List<B>
/**
 * @category Apply
 * @since 0.1.20
 */
export declare const apFirst: <B>(fb: List<B>) => <A>(fa: List<A>) => List<A>
/**
 * @category Apply
 * @since 0.1.20
 */
export declare const apSecond: <B>(fb: List<B>) => <A>(fa: List<A>) => List<B>
/**
 * @category Monad
 * @since 0.1.20
 */
export declare const chain: <A, B>(f: (a: A) => List<B>) => (ma: List<A>) => List<B>
/**
 * @category Monad
 * @since 0.1.20
 */
export declare const chainFirst: <A, B>(f: (a: A) => List<B>) => (fa: List<A>) => List<A>
/**
 * @category Foldable
 * @since 0.1.18
 */
export declare const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: List<A>) => B
/**
 * @category Foldable
 * @since 0.1.18
 */
export declare const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: List<A>) => B
/**
 * @category Foldable
 * @since 0.1.18
 */
export declare const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: List<A>) => M
/**
 * @category Traversable
 * @since 0.1.18
 */
export declare const sequence: Traversable1<URI>['sequence']
/**
 * Creates a list with a single element.
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.deepStrictEqual(L.of('a'), L.cons('a', L.nil))
 *
 * @category Applicative
 * @since 0.1.8
 */
export declare const of: <A>(head: A) => List<A>
/**
 * Finds the first index for which a predicate holds.
 *
 * @example
 * import * as O from 'fp-ts/Option'
 * import * as L from 'fp-ts-contrib/List'
 *
 * const f = (a: number): boolean => a % 2 === 0
 * const findIndexEven = L.findIndex(f)
 * assert.deepStrictEqual(findIndexEven(L.nil), O.none)
 * assert.deepStrictEqual(findIndexEven(L.cons(1, L.of(2))), O.some(1))
 * assert.deepStrictEqual(findIndexEven(L.of(1)), O.none)
 *
 * @since 0.1.8
 */
export declare const findIndex: <A>(predicate: Predicate<A>) => (fa: List<A>) => O.Option<number>
/**
 * @category instances
 * @since 0.1.8
 */
export declare const URI = 'List'
/**
 * @category instances
 * @since 0.1.8
 */
export declare type URI = typeof URI
declare module 'fp-ts/es6/HKT' {
  interface URItoKind<A> {
    List: List<A>
  }
}
/**
 * Derives an `Eq` over the `List` of a given element type from the `Eq` of that type.
 * The derived `Eq` defines two lists as equal if all elements of both lists
 * are compared equal pairwise with the given `E`. In case of lists of different
 * lengths, the result is non equality.
 *
 * @example
 * import { eqString } from 'fp-ts/Eq'
 * import * as L from 'fp-ts-contrib/List'
 *
 * const E = L.getEq(eqString)
 * assert.strictEqual(E.equals(L.cons('a', L.of('b')), L.cons('a', L.of('b'))), true)
 * assert.strictEqual(E.equals(L.of('x'), L.nil), false)
 *
 * @category instances
 * @since 0.1.8
 */
export declare const getEq: <A>(E: Eq.Eq<A>) => Eq.Eq<List<A>>
/**
 * @category instances
 * @since 0.1.20
 */
export declare const getShow: <A>(S: Show<A>) => Show<List<A>>
/**
 * @category instances
 * @since 0.1.20
 */
export declare const getSemigroup: <A>() => Semigroup<List<A>>
/**
 * @category instances
 * @since 0.1.20
 */
export declare const getMonoid: <A>() => Monoid<List<A>>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Functor: Functor1<URI>
/**
 * @category instances
 * @since 0.1.20
 */
export declare const Apply: Apply1<URI>
/**
 * @category instances
 * @since 0.1.20
 */
export declare const Applicative: Applicative1<URI>
/**
 * @category instances
 * @since 0.1.20
 */
export declare const Monad: Monad1<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Foldable: Foldable1<URI>
/**
 * @category instances
 * @since 0.1.18
 */
export declare const Traversable: Traversable1<URI>
/**
 * @category instances
 * @since 0.1.8
 */
export declare const list: Functor1<URI> & Foldable1<URI> & Traversable1<URI>
/**
 * @since 0.1.20
 */
export declare const bindTo: <N extends string>(name: N) => <A>(fa: List<A>) => List<{ [K in N]: A }>
/**
 * @since 0.1.20
 */
export declare const bind: <N extends string, A, B>(
  name: Exclude<N, keyof A>,
  f: (a: A) => List<B>
) => (fa: List<A>) => List<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>
/**
 * @since 0.1.20
 */
export declare const apS: <A, N extends string, B>(
  name: Exclude<N, keyof A>,
  fb: List<B>
) => (fa: List<A>) => List<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>
/**
 * Tests whether a list is an empty list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.strictEqual(L.isNil(L.nil), true)
 * assert.strictEqual(L.isNil(L.of(6)), false)
 *
 * @since 0.1.8
 */
export declare const isNil: <A>(a: List<A>) => a is Nil
/**
 * Tests whether a list is a non empty list.
 *
 * @example
 * import * as L from 'fp-ts-contrib/List'
 *
 * assert.strictEqual(L.isCons(L.nil), false)
 * assert.strictEqual(L.isCons(L.of(1)), true)
 *
 * @since 0.1.8
 */
export declare const isCons: <A>(a: List<A>) => a is Cons<A>
