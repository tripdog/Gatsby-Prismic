class PrismicError extends Error {
  constructor(message, args) {
    super(message);
    this.url = args.url;
    this.response = args.response;
  }
}
class ForbiddenError extends PrismicError {
}
class ConflictError extends PrismicError {
}
class NotFoundError extends PrismicError {
}
class InvalidPayloadError extends PrismicError {
}
class MissingFetchError extends Error {
}

const DEFAULT_CUSTOM_TYPES_API_ENDPOINT = "https://customtypes.prismic.io/customtypes";
const createPostFetchRequestInit = (body) => {
  return {
    method: "post",
    body: JSON.stringify(body)
  };
};
const createClient = (...args) => new CustomTypesClient(...args);
class CustomTypesClient {
  constructor(config) {
    this.repositoryName = config.repositoryName;
    this.endpoint = config.endpoint || DEFAULT_CUSTOM_TYPES_API_ENDPOINT;
    this.token = config.token;
    if (typeof config.fetch === "function") {
      this.fetchFn = config.fetch;
    } else if (typeof globalThis.fetch === "function") {
      this.fetchFn = globalThis.fetch;
    } else {
      throw new MissingFetchError("A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` config parameter.");
    }
    if (this.fetchFn === globalThis.fetch) {
      this.fetchFn = this.fetchFn.bind(globalThis);
    }
  }
  async getAll(params) {
    return await this.fetch("", params);
  }
  async getByID(id, params) {
    return await this.fetch(id, params);
  }
  async insert(customType, params) {
    await this.fetch("insert", params, createPostFetchRequestInit(customType));
    return customType;
  }
  async update(customType, params) {
    await this.fetch("update", params, createPostFetchRequestInit(customType));
    return customType;
  }
  async remove(id, params) {
    await this.fetch(id, params, {
      method: "delete"
    });
    return id;
  }
  async getAllSharedSlices(params) {
    return await this.fetch("/slices", params);
  }
  async getSharedSliceByID(id, params) {
    return await this.fetch(`/slices/${id}`, params);
  }
  async insertSharedSlice(slice, params) {
    await this.fetch("/slices/insert", params, createPostFetchRequestInit(slice));
    return slice;
  }
  async updateSharedSlice(slice, params) {
    await this.fetch("/slices/update", params, createPostFetchRequestInit(slice));
    return slice;
  }
  async removeSharedSlice(id, params) {
    await this.fetch(`/slices/${id}`, params, {
      method: "delete"
    });
    return id;
  }
  async fetch(path, params = {}, requestInit = {}) {
    const url = new URL(path, `${params.endpoint || this.endpoint}/`).toString();
    const res = await this.fetchFn(url, {
      headers: {
        "Content-Type": "application/json",
        repository: params.repositoryName || this.repositoryName,
        Authorization: `Bearer ${params.token || this.token}`
      },
      ...requestInit
    });
    switch (res.status) {
      case 200: {
        return await res.json();
      }
      case 201:
      case 204: {
        return void 0;
      }
      case 400: {
        const text = await res.text();
        throw new InvalidPayloadError(text, { url, response: text });
      }
      case 403: {
        const json = await res.json();
        throw new ForbiddenError(json.message, { url, response: json });
      }
      case 409: {
        throw new ConflictError("The provided ID is already used. A unique ID must be provided.", { url });
      }
      case 404:
      case 422: {
        throw new NotFoundError("An entity with a matching ID could not be found.", { url });
      }
    }
    throw new PrismicError("An invalid API response was returned", { url });
  }
}

export { ConflictError, CustomTypesClient, ForbiddenError, InvalidPayloadError, MissingFetchError, NotFoundError, PrismicError, createClient };
