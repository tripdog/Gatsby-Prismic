"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createImgixGatsbyImageSchemaFieldConfig = exports.createImgixGatsbyImageFieldConfig = void 0;
var common_tags_1 = require("common-tags");
var Do_1 = require("fp-ts-contrib/lib/Do");
var function_1 = require("fp-ts/function");
var T = __importStar(require("fp-ts/Task"));
var TE = __importStar(require("fp-ts/TaskEither"));
var gatsby_plugin_image_1 = require("gatsby-plugin-image");
var graphql_utils_1 = require("gatsby-plugin-image/graphql-utils");
var R = __importStar(require("ramda"));
var fetchBase64Image_1 = require("../../api/fetchBase64Image");
var createExternalHelper_1 = require("../../common/createExternalHelper");
var fpTsUtils_1 = require("../../common/fpTsUtils");
var utils_1 = require("../../common/utils");
var buildGatsbyImageDataBaseArgs_1 = require("./buildGatsbyImageDataBaseArgs");
var graphqlTypes_1 = require("./graphqlTypes");
var resolveDimensions_1 = require("./resolveDimensions");
var resolveGatsbyImageData = function (_a) {
    var resolveUrl = _a.resolveUrl, imgixClient = _a.imgixClient, _b = _a.resolveWidth, resolveWidth = _b === void 0 ? function () { return undefined; } : _b, _c = _a.resolveHeight, resolveHeight = _c === void 0 ? function () { return undefined; } : _c, cache = _a.cache, defaultParams = _a.defaultParams;
    return function (rootValue, unsafeResolverArgs) { return __awaiter(void 0, void 0, void 0, function () {
        var _a, _b;
        return __generator(this, function (_c) {
            return [2 /*return*/, function_1.pipe(Do_1.Do(TE.taskEither)
                    .sequenceSL(function () { return ({
                    url: utils_1.resolveUrlFromSourceData(resolveUrl)(rootValue),
                    manualWidth: function_1.pipe(utils_1.taskEitherFromSourceDataResolver(resolveWidth)(rootValue), fpTsUtils_1.TaskOptionFromTE, TE.fromTask),
                    manualHeight: function_1.pipe(utils_1.taskEitherFromSourceDataResolver(resolveHeight)(rootValue), fpTsUtils_1.TaskOptionFromTE, TE.fromTask),
                }); })
                    .let('safeResolverArgs', __assign(__assign({}, unsafeResolverArgs), { imgixParams: graphqlTypes_1.unTransformParams((_a = unsafeResolverArgs.imgixParams) !== null && _a !== void 0 ? _a : {}), placeholderImgixParams: graphqlTypes_1.unTransformParams((_b = unsafeResolverArgs.placeholderImgixParams) !== null && _b !== void 0 ? _b : {}) }))
                    .bindL('dimensions', function (_a) {
                    var url = _a.url, manualWidth = _a.manualWidth, manualHeight = _a.manualHeight;
                    return resolveDimensions_1.resolveDimensions({
                        url: url,
                        manualHeight: manualHeight,
                        manualWidth: manualWidth,
                        cache: cache,
                        client: imgixClient,
                    });
                })
                    .letL('baseImageDataArgs', function (_a) {
                    var url = _a.url, dimensions = _a.dimensions, safeResolverArgs = _a.safeResolverArgs;
                    return buildGatsbyImageDataBaseArgs_1.buildGatsbyImageDataBaseArgs({
                        url: url,
                        dimensions: dimensions,
                        resolverArgs: safeResolverArgs,
                        defaultParams: defaultParams,
                        imgixClient: imgixClient,
                    });
                })
                    .bindL('placeholderData', function (_a) {
                    var url = _a.url, baseImageDataArgs = _a.baseImageDataArgs, safeResolverArgs = _a.safeResolverArgs;
                    if (safeResolverArgs.placeholder === 'blurred') {
                        return function_1.pipe(gatsby_plugin_image_1.getLowResolutionImageURL(__assign(__assign({}, baseImageDataArgs), { options: __assign(__assign({}, baseImageDataArgs), { imgixParams: __assign(__assign(__assign({}, defaultParams), safeResolverArgs.imgixParams), safeResolverArgs.placeholderImgixParams) }) })), fetchBase64Image_1.fetchImgixBase64Image(cache), TE.map(function (base64Data) { return ({
                            placeholder: { fallback: base64Data },
                        }); }));
                    }
                    if (safeResolverArgs.placeholder === 'dominantColor') {
                        return function_1.pipe(fetchBase64Image_1.fetchImgixDominantColor(cache)(function (params) {
                            return imgixClient.buildURL(url, __assign(__assign(__assign(__assign({}, defaultParams), safeResolverArgs.imgixParams), safeResolverArgs.placeholderImgixParams), params));
                        }), TE.map(function (dominantColor) { return ({
                            backgroundColor: dominantColor,
                        }); }));
                    }
                    return TE.right({});
                })
                    .return(function (_a) {
                    var baseImageDataArgs = _a.baseImageDataArgs, placeholderData = _a.placeholderData;
                    return (__assign(__assign({}, gatsby_plugin_image_1.generateImageData(__assign({}, baseImageDataArgs))), placeholderData));
                }), TE.getOrElseW(function () { return T.of(undefined); }))()];
        });
    }); };
};
var createImgixGatsbyImageFieldConfig = function (_a) {
    var cache = _a.cache, imgixClient = _a.imgixClient, resolveUrl = _a.resolveUrl, defaultParams = _a.defaultParams, paramsInputType = _a.paramsInputType, placeholderEnumType = _a.placeholderEnumType, resolveWidth = _a.resolveWidth, resolveHeight = _a.resolveHeight;
    var defaultConfig = graphql_utils_1.getGatsbyImageFieldConfig(resolveGatsbyImageData({
        cache: cache,
        imgixClient: imgixClient,
        resolveUrl: resolveUrl,
        defaultParams: defaultParams,
        resolveWidth: resolveWidth,
        resolveHeight: resolveHeight,
    }), // TODO: remove cast when PR to Gatsby has been merged
    {});
    var defaultArgs = defaultConfig.args;
    // ⚠️ KEEP THESE IN SYNC WITH IImgixGatsbyImageDataArgs!! ⚠️
    var modifiedConfig = __assign(__assign({}, defaultConfig), { args: __assign(__assign({}, R.pick([
            'layout',
            'width',
            'height',
            'aspectRatio',
            'outputPixelDensities',
            'breakpoints',
            'sizes',
            'backgroundColor',
        ], defaultArgs)), { imgixParams: {
                type: paramsInputType,
                description: common_tags_1.stripIndent(templateObject_1 || (templateObject_1 = __makeTemplateObject(["This argument is used to set parameters to instruct imgix to transform the image. \n        \n        All of imgix's parameters can be found here: https://docs.imgix.com/apis/rendering\n        "], ["This argument is used to set parameters to instruct imgix to transform the image. \n        \n        All of imgix's parameters can be found here: https://docs.imgix.com/apis/rendering\n        "]))),
            }, placeholderImgixParams: {
                type: paramsInputType,
                description: common_tags_1.stripIndent(templateObject_2 || (templateObject_2 = __makeTemplateObject(["This argument is used to set parameters to instruct imgix to transform the placeholder image. By default all parameters passed to 'imgixParams' are already set here, but this can be used to override or set extra parameters. \n        \n        All of imgix's parameters can be found here: https://docs.imgix.com/apis/rendering\n        "], ["This argument is used to set parameters to instruct imgix to transform the placeholder image. By default all parameters passed to 'imgixParams' are already set here, but this can be used to override or set extra parameters. \n        \n        All of imgix's parameters can be found here: https://docs.imgix.com/apis/rendering\n        "]))),
            }, placeholder: {
                type: placeholderEnumType,
                description: common_tags_1.stripIndent(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n          Format of generated placeholder image, displayed while the main image loads.\n          BLURRED: a blurred, low resolution image, encoded as a base64 data URI (default)\n          DOMINANT_COLOR: a solid color, calculated from the dominant color of the image.\n          NONE: no placeholder. Set \"backgroundColor\" to use a fixed background color."], ["\n          Format of generated placeholder image, displayed while the main image loads.\n          BLURRED: a blurred, low resolution image, encoded as a base64 data URI (default)\n          DOMINANT_COLOR: a solid color, calculated from the dominant color of the image.\n          NONE: no placeholder. Set \"backgroundColor\" to use a fixed background color."]))),
            }, widthTolerance: {
                type: 'Float',
                description: common_tags_1.stripIndent(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\n          This argument affects the breakpoints used for the srcsets, dictates the maximum tolerated size difference between an image's downloaded size and its rendered size. For example: setting this value to 0.1 means that an image will not render more than 10% larger or smaller than its native size. In practice, the image URLs generated for a width-based srcset attribute will grow by twice this rate. A lower tolerance means images will render closer to their native size (thereby increasing perceived image quality), but a large srcset list will be generated and consequently users may experience lower rates of cache-hit for pre-rendered images on your site.\n\n          By default this rate is set to 8 percent, which we consider to be the ideal rate for maximizing cache hits without sacrificing visual quality. Users can specify their own width tolerance by providing a positive scalar value as widthTolerance to the third options object:"], ["\n          This argument affects the breakpoints used for the srcsets, dictates the maximum tolerated size difference between an image's downloaded size and its rendered size. For example: setting this value to 0.1 means that an image will not render more than 10% larger or smaller than its native size. In practice, the image URLs generated for a width-based srcset attribute will grow by twice this rate. A lower tolerance means images will render closer to their native size (thereby increasing perceived image quality), but a large srcset list will be generated and consequently users may experience lower rates of cache-hit for pre-rendered images on your site.\n\n          By default this rate is set to 8 percent, which we consider to be the ideal rate for maximizing cache hits without sacrificing visual quality. Users can specify their own width tolerance by providing a positive scalar value as widthTolerance to the third options object:"]))),
                defaultValue: 0.08,
            }, srcSetMinWidth: {
                type: 'Int',
                description: common_tags_1.stripIndent(templateObject_5 || (templateObject_5 = __makeTemplateObject(["\n          This argument determines the minimum srcset width that is generated. The default is 100px.\n        "], ["\n          This argument determines the minimum srcset width that is generated. The default is 100px.\n        "]))),
                defaultValue: 100,
            }, srcSetMaxWidth: {
                type: 'Int',
                description: common_tags_1.stripIndent(templateObject_6 || (templateObject_6 = __makeTemplateObject(["\n          This argument determines the maximum srcset width that is generated, if the layout type is FULL_WIDTH. If the layout type is CONSTRAINED, the width argument will be used. Furthermore, in every case, the maximum srcset width is constrained by the width of the source image. The default is 8192px, which is the render limit of the imgix service.\n        "], ["\n          This argument determines the maximum srcset width that is generated, if the layout type is FULL_WIDTH. If the layout type is CONSTRAINED, the width argument will be used. Furthermore, in every case, the maximum srcset width is constrained by the width of the source image. The default is 8192px, which is the render limit of the imgix service.\n        "]))),
                defaultValue: 8192,
            } }) });
    return modifiedConfig;
};
exports.createImgixGatsbyImageFieldConfig = createImgixGatsbyImageFieldConfig;
exports.createImgixGatsbyImageSchemaFieldConfig = createExternalHelper_1.createExternalHelper(exports.createImgixGatsbyImageFieldConfig);
var templateObject_1, templateObject_2, templateObject_3, templateObject_4, templateObject_5, templateObject_6;
//# sourceMappingURL=createImgixGatsbyImageDataFieldConfig.js.map