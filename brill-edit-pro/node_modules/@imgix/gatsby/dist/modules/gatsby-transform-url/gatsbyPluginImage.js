"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGatsbyImageData = exports.GATSBY_IMAGE_HOOK_OPTS_KEYS = void 0;
var gatsby_plugin_image_1 = require("gatsby-plugin-image");
var uri_1 = require("../../common/uri");
var breakpoints_1 = require("./breakpoints");
var common_1 = require("./common");
var urlBuilder = function (client) { return function (_a) {
    var _b;
    var baseUrl = _a.baseUrl, width = _a.width, height = _a.height, _c = _a.options, options = _c === void 0 ? {} : _c;
    var manualQuality = options.breakpointsWithData
        ? (_b = options.breakpointsWithData.find(function (breakpoint) { return breakpoint.width === width; })) === null || _b === void 0 ? void 0 : _b.quality
        : undefined;
    return client.buildURL(baseUrl, __assign(__assign(__assign({ fit: 'min' }, (manualQuality && { q: manualQuality })), options.imgixParams), { w: width, h: height }));
}; };
// This is a workaround to ensure that the props that are extracted in the component are always in sync with this hook's options
exports.GATSBY_IMAGE_HOOK_OPTS_KEYS = [
    'src',
    'imgixParams',
    'width',
    'height',
    'layout',
    'breakpoints',
    'widthTolerance',
    'srcsetMinWidth',
    'srcsetMaxWidth',
    'aspectRatio',
    'sourceWidth',
    'sourceHeight',
    'backgroundColor',
    'disableVariableQuality',
];
// This is the actual type check. It ensures that a key of the object type can be "assigned" to a key of the list above. Therefore if a new key is added to the opts type, this will throw a type error
var __KEY_CHECK = '';
function getGatsbyImageData(_a) {
    var src = _a.src, sourceWidth = _a.sourceWidth, sourceHeight = _a.sourceHeight, aspectRatio = _a.aspectRatio, widthTolerance = _a.widthTolerance, srcsetMinWidth = _a.srcsetMinWidth, srcsetMaxWidth = _a.srcsetMaxWidth, breakpointsOverride = _a.breakpoints, disableVariableQuality = _a.disableVariableQuality, props = __rest(_a, ["src", "sourceWidth", "sourceHeight", "aspectRatio", "widthTolerance", "srcsetMinWidth", "srcsetMaxWidth", "breakpoints", "disableVariableQuality"]);
    var layout = props.layout;
    if (layout == null) {
        throw new Error("[@imgix/gatsby] A valid 'layout' is required. Valid image layouts are 'fixed', 'fullWidth', and 'constrained'. Found " + layout);
    }
    var width = props.width;
    if (layout === 'fixed' && width == null) {
        throw new Error("[@imgix/gatsby] a 'width' is required when layout is 'fixed'. Found " + width);
    }
    var bothWidthAndHeightSet = props.width != null && props.height != null;
    var bothSourcesOrAspectRatioSet = (sourceWidth != null && sourceHeight != null) || aspectRatio != null;
    if (!bothWidthAndHeightSet && !bothSourcesOrAspectRatioSet) {
        throw new Error("[@imgix/gatsby] 'aspectRatio' or 'sourceWidth' and 'sourceHeight' needed when one of width/height are not passed.");
    }
    var client = common_1.createImgixClient({
        domain: uri_1.parseHost(src),
        libraryParam: 'gatsbyHook',
    });
    var breakpointsData = breakpoints_1.generateBreakpoints(__assign(__assign({}, (layout === 'fullWidth'
        ? { layout: 'fullWidth' }
        : { layout: layout, width: width })), { srcsetMinWidth: srcsetMinWidth,
        srcsetMaxWidth: srcsetMaxWidth,
        widthTolerance: widthTolerance,
        sourceWidth: sourceWidth,
        disableVariableQuality: disableVariableQuality }));
    var _b = calculateSourceWidthAndHeight({
        sourceWidth: sourceWidth,
        sourceHeight: sourceHeight,
    }), sourceWidthOverride = _b.sourceWidth, sourceHeightOverride = _b.sourceHeight;
    return gatsby_plugin_image_1.getImageData(__assign(__assign(__assign({ baseUrl: uri_1.parsePath(src), sourceWidth: sourceWidthOverride, sourceHeight: sourceHeightOverride, aspectRatio: aspectRatio, urlBuilder: urlBuilder(client), pluginName: '@imgix/gatsby', formats: ['auto'], breakpoints: breakpointsOverride !== null && breakpointsOverride !== void 0 ? breakpointsOverride : breakpointsData.breakpoints }, props), { outputPixelDensities: breakpointsData.outputPixelDensities }), { layout: layout, options: {
            imgixParams: props.imgixParams,
            breakpointsWithData: breakpointsData.breakpointsWithData,
        } }));
}
exports.getGatsbyImageData = getGatsbyImageData;
/**
 * This function is designed to help override Gatsby's fixed layout logic.
 * Gatsby will not generate breakpoints above the sourceWidth for fixed images, but we need to force this, since we don't know the source width and we can use fit=min to ensure images are not scaled up.
 * The result is meant to be passed to `getImageData`
 */
var calculateSourceWidthAndHeight = function (_a) {
    var sourceWidth = _a.sourceWidth, sourceHeight = _a.sourceHeight;
    if (sourceWidth != null) {
        // If sourceWidth is already defined, just return as is, with sourceHeight (if set)
        return { sourceWidth: sourceWidth, sourceHeight: sourceHeight };
    }
    // Now we should "fake" the sourceWidth to the max imgix render size (8192px).
    // We explicitly *don't* pass sourceHeight since that could cause a weird
    // aspect ratio to be set.
    return { sourceWidth: common_1.MAX_WIDTH };
};
//# sourceMappingURL=gatsbyPluginImage.js.map